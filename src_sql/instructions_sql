CREATE DATABASE biblio CHARACTER SET 'utf8';
USE biblio;

-- Table des genres

CREATE TABLE genres (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL,
  nom_genre VARCHAR(20) NOT NULL UNIQUE, 
  PRIMARY KEY pk_genre(id),
  INDEX ind_genres(nom_genre)
)
ENGINE = INNODB;


-- table des pays

CREATE TABLE pays (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL,
  nom_p VARCHAR(30) NOT NULL UNIQUE,
  PRIMARY KEY pk_pays(id),
  INDEX ind_pays(nom_p)
  )
  ENGINE = INNODB;

-- table des langues

CREATE TABLE langues (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL,
  nom_lan VARCHAR(30) NOT NULL UNIQUE,
  nbre INT UNSIGNED,
  PRIMARY KEY pk_langues(id),
  INDEX ind_langue(nom_lan),
  INDEX ind_nbre(nbre)
  )
  ENGINE = INNODB;



-- table des localisation, ma bibliothèque se trouvant éclatée en 3 lieux éloignés!

CREATE TABLE localisation (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL,
  nom_lieu VARCHAR(30) NOT NULL UNIQUE,
  PRIMARY KEY pk_localisation(id)
  )
  ENGINE = INNODB;



-- Table des auteurs

CREATE TABLE auteurs (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL,
  nom_aut VARCHAR(40) NOT NULL,
  prenom_aut VARCHAR(40),
  pays_aut INT UNSIGNED,
  annee_naiss INT UNSIGNED,
  annee_deces INT UNSIGNED,
  PRIMARY KEY pk_auteur(id),
  infos LONGTEXT,
  FOREIGN KEY fk_pays (pays_aut) REFERENCES pays(id),
  INDEX ind_aut(nom_aut,prenom_aut)
)
ENGINE = INNODB;

-- Table des livres  pourquoi les fk ne passent elles pas ?

CREATE TABLE livres (
id INT UNSIGNED AUTO_INCREMENT NOT NULL,
  nom_liv VARCHAR(100) NOT NULL,
  cote VARCHAR(20),
  genre INT UNSIGNED NOT NULL,
  langue INT UNSIGNED NOT NULL,
  date_pub DATE,
  date_acq DATE,
  un_resume BOOLEAN,
  lieux INT UNSIGNED NOT NULL,
  PRIMARY KEY pk_livre(id),
  INDEX ind_titre(nom_liv),
  FOREIGN KEY fk_genre(genre) REFERENCES genres(id),
  FOREIGN KEY fk_langue(langue) REFERENCES langues(id),
  FOREIGN KEY fk_lieux(lieux) REFERENCES localisation(id)
  )
ENGINE = INNODB;

-- table auteurs / genre : un auteur peut écrire dans plusieurs genres, dans plusieurs langues, et un livre peut avoir plusieurs auteurs

CREATE TABLE auteur_genre (
  id_auteur INT UNSIGNED NOT NULL,
  id_genre INT UNSIGNED NOT NULL,
  PRIMARY KEY pk_auteur_genre (id_auteur,id_genre),
  FOREIGN KEY fk_aut (id_auteur) REFERENCES auteurs(id),
  FOREIGN KEY fk_genre(id_genre) REFERENCES genres(id)
  )
ENGINE = INNODB;

CREATE TABLE auteur_langue (
  id_auteur INT UNSIGNED NOT NULL,
  id_langue INT UNSIGNED NOT NULL,
  PRIMARY KEY pk_auteur_langue (id_auteur,id_langue),
  FOREIGN KEY fk_aut (id_auteur) REFERENCES auteurs(id),
  FOREIGN KEY fk_langue(id_langue) REFERENCES langues(id)
  )
ENGINE = INNODB;

CREATE TABLE  livre_auteurs(
  id_auteur INT UNSIGNED NOT NULL,
  id_livre INT UNSIGNED NOT NULL,
  PRIMARY KEY pk_livre_auteur (id_livre,id_auteur),
  FOREIGN KEY fk_aut (id_auteur) REFERENCES auteurs(id),
  FOREIGN KEY fk_livre(id_livre) REFERENCES livres(id)
  )
ENGINE = INNODB;

-- Je trouve que ce serait bien d'aboir une table pour enregitrer des résumés et avoir une recherche en fulltext que ne permet pas INNODB

CREATE TABLE resume_livres (
  id_livre INT UNSIGNED NOT NULL,             -- pas d'auto increment. Ce sera le même identifiant que dans la fiche livre
  resume LONGTEXT,
  PRIMARY KEY pk_resume(id_livre),
  FULLTEXT INDEX ind_resume (resume)
  )
ENGINE = MYISAM;



-- Tables pour l'enregistrement des cotes

CREATE TABLE cote1 (
id_cote1 INT UNSIGNED AUTO_INCREMENT NOT NULL,
code VARCHAR(3),
nom VARCHAR(50),
PRIMARY KEY pk_cote1(id_cote1)
)
ENGINE = INNODB;

CREATE TABLE cote2 (
id_cote2 INT UNSIGNED AUTO_INCREMENT NOT NULL,
cote1 INT UNSIGNED NOT NULL,
code VARCHAR(3),
nom VARCHAR(50),
PRIMARY KEY pk_cote2(id_cote2),
  FOREIGN KEY fk_idcote1 (cote1) REFERENCES cote1(id_cote1)
)
ENGINE = INNODB;

CREATE TABLE cote3 (
id_cote3 INT UNSIGNED AUTO_INCREMENT NOT NULL,
cote2 INT UNSIGNED NOT NULL,
code VARCHAR(5),
nom VARCHAR(50),
PRIMARY KEY pk_cote3(id_cote3),
  FOREIGN KEY fk_idcote2 (cote2) REFERENCES cote2(id_cote2)
)
ENGINE = INNODB;


CREATE TABLE cote4 (
-- compteur. Je ne mets pas un compteur entier, mais un compteur decimal afin de pouvoir insérer des cotes en cas
-- de besoin, ie s'il faut par exemple insérr un doublon, ou un épisode oublié dans un roman à épisodes
id_cote4 INT UNSIGNED NOT NULL,
cote3 INT UNSIGNED NOT NULL,
compteur DECIMAL UNSIGNED,
PRIMARY KEY pk_cote4(id_cote4),
  FOREIGN KEY fk_idcote3 (cote3) REFERENCES cote3(id_cote3)
)
ENGINE = INNODB;





-- fonction pour mettre une majuscule en début d'un mot (pour les noms propre et les noms de genre)

-- Triggers pour homogénéiser les noms dans les bases de données
      

-- Triggers
-- Sur la table langues:

DELIMITER |
CREATE TRIGGER before_insert_langues BEFORE INSERT ON langues
FOR EACH ROW
BEGIN
    SET NEW.nom_lan = UPPER(NEW.nom_lan);
  END; |
    DELIMITER ;

    DELIMITER |
CREATE TRIGGER before_update_langues BEFORE UPDATE ON langues
FOR EACH ROW
BEGIN
    SET NEW.nom_lan = UPPER(NEW.nom_lan);
  END; |
    DELIMITER ;


-- Sur la table pays:

DELIMITER |
CREATE TRIGGER before_insert_pays BEFORE INSERT ON pays
FOR EACH ROW
BEGIN
    SET NEW.nom_p = UPPER(NEW.nom_p);
  END; |
    DELIMITER ;

DELIMITER |
CREATE TRIGGER before_update_pays BEFORE UPDATE ON pays
FOR EACH ROW
BEGIN
    SET NEW.nom_p = UPPER(NEW.nom_p);
  END; |
    DELIMITER ;

   -- Sur la table auteurs:

DELIMITER |
CREATE TRIGGER before_insert_auteurs BEFORE INSERT ON auteurs
FOR EACH ROW
BEGIN
    SET NEW.nom_aut = UPPER(NEW.nom_aut);
  END; |
    DELIMITER ;

DELIMITER |
CREATE TRIGGER before_update_auteurs BEFORE UPDATE ON auteurs
FOR EACH ROW
BEGIN
    SET NEW.nom_aut = UPPER(NEW.nom_aut);
  END; |
    DELIMITER ;

-- Sur la table localisations:

DELIMITER |
CREATE TRIGGER before_insert_localisation BEFORE INSERT ON localisation
FOR EACH ROW
BEGIN
    SET NEW.nom_lieu = UPPER(NEW.nom_lieu);
  END; |
    DELIMITER ;

DELIMITER |
CREATE TRIGGER before_update_localisation BEFORE UPDATE ON localisation
FOR EACH ROW
BEGIN
    SET NEW.nom_lieu = UPPER(NEW.nom_lieu);
  END; |
    DELIMITER ;